---
title: "EIA API - US48 Demand for Electricity Backfill"
format:
  html:
    code-fold: true
jupyter: python3
---

The goal of this doc is to execute an initial data pull of the demand for electricity in the US (lower 48) from the EIA API. This includes the following functionality:

- Setting parameters and pulling the data
- Data quality checks
- Saving the data and creating a log file
- Data profiling

## Load libraries

We will pull the data from the EIA API using a set of functions on the `eia_api.py` file. This includes the following functions:

- `eia_get` - A function for query data from the API. Can pull up to 5000 rows per call
- `eia_backfile` - A wrapper function, using batches requests from the API using the `eia_get` function to serve large requests (more than 5000 rows)
- `day_offset` - A helper function creates a vector of dates equally spaced by days
- `hour_offset` - A helper function creates a vector of dates equally spaced by days


```{python}
import eia_api
import plot_fc
```

The `eia_api.py` file imports the following libraries:

- `pandas` - for data processing
- `datetime` - to work with dates and time objects
- `requests` - to send `GET` requests to the EIA API

In addition, we will use the following libraries:

- `os` - load environment variables
- `numpy` - to create sequences (vectors)
- `plotly` - visualize the data
- `pathlib` - set file path
- `ydata_profiling` - for data profiling


```{python}
import os
import datetime
from zoneinfo import ZoneInfo
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from pathlib import Path
from ydata_profiling import ProfileReport
from darts import TimeSeries
from darts.models.forecasting.linear_regression_model import LinearRegressionModel
```


## Setting Parameters

Next, we will set the backfile parameters:
```{python}
api_path = "electricity/rto/region-data/data"
facets = {
    "respondent": "US48",
    "type": "D"
}

start = datetime.datetime(2015, 7, 1, 5)
end = datetime.datetime(2024, 2, 8, 1)

offset = 2250

```

We will use the `getenv` function from the `os` library to pull the EIA API key, which is stored as an environment variable named `EIA_API_KEY`:

```{python}
eia_api_key = os.getenv('EIA_API_KEY')
```

We will use the `eia_metadata` function to pull the series metadata. Note that to pull metadata from the API, we will use as the `api_path` the series routh path and drop the `/data` extension (which is used to pull data):

```{python}
metadata = eia_api.eia_metadata(api_key = eia_api_key, api_path = "electricity/rto/region-data/")
```

Depending on the API path, the API returns some useful information about the series available on the path:

```{python}
metadata.meta.keys()
```

One useful data point is the start and end period of the series:

```{python}
print(metadata.meta["startPeriod"])
print(metadata.meta["endPeriod"])
```

## Pulling the Data

By default, the API has a 5000-row limitation per pull. The eia_backfill function enables the handling of a larger data request by sending a batch request and appending back the data:

```{python}
df = eia_api.eia_backfile(api_key = eia_api_key, 
        api_path = api_path, 
        facets = facets, 
        start = start,
        end = end,
        offset = offset) 
```


The DataFrame head:
```{python}
df.data.head(10)
```

And, the DataFrame tail:
```{python}
df.data.tail(10)
```


## Data Quality checks

We will runn the following data quality checks:

- Check that the series timestamp is regular (e.g., equaliy spaced)
- Check for missing values
- Check for match between the start and end of the series and the request settings
- Create a log file 

### Check the Series Timestamp

```{python}
ts_obj = pd.DataFrame(np.arange(start = start, stop = end + datetime.timedelta(hours = 1), step = datetime.timedelta(hours = 1)).astype(datetime.datetime), columns=["index"])
ts_obj  = ts_obj.merge(df.data, left_on = "index", right_on = "period", how="left")
```

### Plot the Series

We will use Plotly to visualize the series:

```{python}
d = df.data.sort_values(by = ["period"])
d = d[d["respondent"] == "US48"]
p = go.Figure()
p.add_trace(go.Scatter(x = ts_obj["index"], y = ts_obj["value"],
                       mode='lines',
                    name='data',
                    line=dict(color='royalblue', width=2)))
p.show()
```


### Create Log and Check for Missing values

```{python}
log = {
    "index": 1,
    "respondent": "US48",
    "respondent_type": "Demand",
    "time": datetime.datetime.now(),
    "start": start,
    "end": end,
    "start_act": ts_obj["period"].min(),
    "end_act": ts_obj["period"].max(),
    "start_match": ts_obj["period"].min() == start, 
    "end_match": ts_obj["period"].max() == end, 
     "n_obs": len(ts_obj),
    "na": ts_obj["value"].isna().sum(),
    "type": "backfill",
    "update": False,
    "success": False

}

log_file = pd.DataFrame([log])

log_file
```


Last but not least, we will check if the start and end of the series match the GET request settings and save the data and log:
```{python}
if (log_file.iloc[0]["end"] == log_file.iloc[0]["end_act"] and 
    log_file.iloc[0]["start"] == log_file.iloc[0]["start_act"] and
    log_file.iloc[0]["na"] == 0):
    log_file.loc[0, "success"] = True
    print("Save the data into CSV file")
    df.data.to_csv("data/us48.csv", index = False)
    log_file.loc[0, "update"] = True
    print("Save the metadata into CSV file")
    log_file.to_csv("data/us48_metadata.csv", index = False)

    
else:
    log_file.iloc[0]["success"] = False
    log_file.iloc[0]["update"] = False
```


## Data Profiling

The ydata-profiling library provides a detailed report about the data structure with the `ProfileReport` function:

```{python}
profile = ProfileReport(df.data, title="Profiling Report")
profile
```

## Create forecast

```{python}
h = 24
freq = 24
num_samples = 500
```

```{python}


forecast_start = df.data["period"].max().floor(freq = "d")

forecast_start

ts_start = forecast_start - datetime.timedelta(hours = freq * 365 * 2)
```

```{python}

d1 = d[(d["period"] > ts_start) & (d["period"] < forecast_start)]

input = TimeSeries.from_dataframe(d1,time_col= "period", value_cols= "value")

```

```{python}
lr_model = LinearRegressionModel(lags= [ -freq, -7 * freq,  - 365 * freq],
                                 likelihood= "quantile", 
                                 quantiles = [0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95])

lr_model.fit(input)
```


```{python}

lr_preds = lr_model.predict(series=input, 
                            n= h, 
                            num_samples = num_samples)

lr_preds.plot(label = "Forecast",low_quantile=0.05, high_quantile=0.95)
```

```{python}
pred = lr_preds.pd_dataframe()
fc = pred.quantile(axis = 1, q = [0.05, 0.5, 0.95]).transpose().reset_index()

fc = fc.rename(columns = {0.05: "lower", 0.5: "mean", 0.95: "upper"})
fc.head()

```

```{python}
label = str(forecast_start.date())

fc["label"] = label


fc_log = {
    "time": datetime.datetime.now(tz=ZoneInfo("UTC")).strftime('%Y-%m-%d %H:%M:%S'),
    "label": label,
    "start": forecast_start,
    "start_act": fc["period"].min(),
    "end_act": fc["period"].max(),
    "h": h,
    "n_obs": len(fc),
    "start_flag": forecast_start == fc["period"].min(),
    "n_obs_flag": h == len(fc),
    "model": "LinearRegressionModel",
    "pi":  0.95,
    "score": False,
    "mape": None,
    "rmse": None,
    "coverage": None
}

fc_log["success"] = fc_log["start_flag"] and fc_log["n_obs_flag"]
fc_log
fc_log_file = pd.DataFrame([fc_log])
```

```{python}
print("Save the forecast into CSV file")
fc.to_csv("data/fc48.csv", index = False)

print("Save the forecast metadata into CSV file")
fc_log_file.to_csv("data/fc48_metadata.csv", index = False)

```


```{python}
def plot_fc(actual,forecast, actual_length = None):
    
    if actual_length is not None:
        actual = actual.tail(n = actual_length)

    p = go.Figure([
        go.Scatter(
            name="Actual",
            x= actual["period"], 
            y= actual["value"],
            mode='lines',
            line= dict(color='royalblue'),
        ), 
        go.Scatter(
            name="Forecast",
            x= forecast["period"], 
            y= forecast["mean"],
            mode='lines',
            line= dict(color='black', dash = "dash"),
        ),
        go.Scatter(
            name= "Prediction Intervals",
            x= forecast["period"], 
            y= forecast["upper"],
            mode='lines',
            marker=dict(color="#444"),
            line=dict(width=0),
            showlegend=True
        ),
        go.Scatter(
            name="Prediction Intervals",
            x= forecast["period"], 
            y= forecast["lower"],
            marker=dict(color="#444"),
            line=dict(width=0),
            mode='lines',
            fillcolor='rgba(68, 68, 68, 0.3)',
            fill='tonexty',
            showlegend=False
        )
    ])

    return p 
```

```{python}
d = df.data.sort_values(by = ["period"])
# d = d[d["respondent"] == "US48"].tail(n = freq * 14)

p = plot_fc(actual = d, forecast = fc, actual_length = freq * 14)

p
```

